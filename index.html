<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Ø¯Ù…Ùˆ Ø¨Ø§Ø²ÛŒ â€” Ù‚Ø·Ø¹ Ù…ÛŒÙˆÙ‡ (Roznamcha)</title>
  <style>
    :root{
      --bg:#0b1320; --panel:#ffffff; --accent:#6c1aa8; --accent-2:#10b981; --muted:#8b95a1;
      --cta:#0ea5a3;
    }
    html,body{height:100%;margin:0;font-family:Vazirmatn,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071226 0%, #071a2b 100%);display:flex;align-items:center;justify-content:center;padding:14px}
    .container{width:100%;max-width:900px;border-radius:14px;background:linear-gradient(180deg,#ffffff,#f8fafc);overflow:hidden;box-shadow:0 20px 60px rgba(2,6,23,.6)}
    header{display:flex;justify-content:space-between;align-items:center;padding:14px 18px;border-bottom:1px solid #eef2f7}
    header h1{margin:0;font-size:1.1rem;color:var(--bg);font-weight:800}
    header .score{font-weight:800;color:var(--muted)}

    .stage{position:relative;background:linear-gradient(180deg,#eaf3ff,#ffffff);height:560px;display:flex;align-items:center;justify-content:center}
    canvas{width:100%;height:100%;display:block}

    .hud{display:flex;gap:12px;align-items:center;padding:12px 18px;border-top:1px solid #eef2f7;background:linear-gradient(180deg,#ffffff,#f8fafc)}
    .hud .info{flex:1;color:#24303a;font-weight:700}
    .hud .timer{font-weight:900;color:var(--accent)}

    /* floating download CTA */
    .cta{position:absolute;left:16px;bottom:16px;z-index:60;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#fff;padding:12px 16px;border-radius:14px;font-weight:900;box-shadow:0 12px 30px rgba(12,20,40,.35);text-decoration:none}

    /* overlay end screen */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(3,7,18,0.45),rgba(3,7,18,0.65));backdrop-filter:blur(2px);z-index:80;display:none}
    .overlay.show{display:flex}
    .card{background:#fff;padding:22px;border-radius:12px;max-width:420px;text-align:center}
    .card h2{margin:0 0 10px 0;color:var(--bg)}
    .card p{color:var(--muted);margin:0 0 18px 0}
    .download-btn{display:inline-block;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#fff;padding:12px 18px;border-radius:10px;text-decoration:none;font-weight:800}

    /* Roznamcha watermark */
    .watermark{position:absolute;right:18px;top:18px;opacity:.08;font-size:42px;color:#000;pointer-events:none;font-weight:900}

    /* responsive */
    @media (max-width:640px){ .stage{height:70vh} .watermark{font-size:30px} }
  </style>
</head>
<body>
  <div class="container" role="application">
    <header>
      <h1>Ø¨Ø²Ù† Ùˆ Ø¨Ø±Ø´ Ø¨Ø²Ù† â€” Ø¯Ù…ÙˆÛŒ Roznamcha</h1>
      <div class="score">Ø§Ù…ØªÛŒØ§Ø²: <span id="score">0</span></div>
    </header>

    <div class="stage">
      <canvas id="gameCanvas" width="900" height="560" style="touch-action: none;" aria-label="Ø¨Ø§Ø²ÛŒ Ù‚Ø·Ø¹ Ù…ÛŒÙˆÙ‡"></canvas>

      <div class="watermark">Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡</div>

      <a class="cta" id="floatingCta" href="https://github.com/MLd10Sar/Esmat/releases/download/v1.0.0/app-release.apk" target="_blank">ðŸ“² Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø§Ù¾ Roznamcha</a>

      <div class="overlay" id="overlay">
        <div class="card">
          <h2 id="overlayTitle">Ø®Ø³ØªÙ‡ Ù†Ø¨Ø§Ø´ÛŒ!</h2>
          <p id="overlayText">Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø­Ø³Ø§Ø¨ Ùˆ Ú¯Ø¯Ø§Ù…ØŒ Ø§Ù¾ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ø±Ø§ Ù†ØµØ¨ Ú©Ù† Ùˆ Ú©Ø³Ø¨â€ŒÙˆÚ©Ø§Ø±Øª Ø±Ø§ Ø³Ø§Ø¯Ù‡ Ú©Ù†.</p>
          <a id="overlayDownload" class="download-btn" href="https://github.com/MLd10Sar/Esmat/releases/download/v1.0.0/app-release.apk" target="_blank">ðŸ“¥ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø§Ù¾ Roznamcha</a>
        </div>
      </div>
    </div>

    <div class="hud">
      <div class="info">Ù…ÛŒÙˆÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØµÙˆØµ Roznamcha Ø±Ø§ Ø¨Ø¨Ø±ÛŒØ¯ ØªØ§ Ù¾ÛŒØ§Ù… ÙˆÛŒÚ˜Ù‡ Ø¨Ø¨ÛŒÙ†ÛŒØ¯.</div>
      <div class="timer">Ø²Ù…Ø§Ù†: <span id="time">60</span>s</div>
    </div>
  </div>

  <script>
    // Fruit Cutter â€” Simple, mobile-friendly, Roznamcha-branded
    (function(){
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const timeEl = document.getElementById('time');
      const overlay = document.getElementById('overlay');
      const overlayTitle = document.getElementById('overlayTitle');
      const overlayText = document.getElementById('overlayText');

      // logical size independent from CSS size
      function fitCanvas(){
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.round(rect.width * devicePixelRatio);
        canvas.height = Math.round(rect.height * devicePixelRatio);
        ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      }
      fitCanvas();
      window.addEventListener('resize', fitCanvas);
      window.addEventListener('load', fitCanvas);
      let score = 0;
      let timeLeft = 60; // seconds
      let running = true;

      function flashScreen(color, duration) {
  const flash = document.createElement('div');
  Object.assign(flash.style, {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    background: color,
    opacity: 0.3,
    pointerEvents: 'none',
    zIndex: 9999,
  });
  document.body.appendChild(flash);
  setTimeout(() => {
    flash.style.transition = 'opacity 0.2s';
    flash.style.opacity = '0';
    setTimeout(() => flash.remove(), 200);
  }, duration);
}

    function shakeScreen(intensity = 5, duration = 200) {
  const container = document.querySelector('.container');
  const originalTransform = container.style.transform || '';
  let start = null;
  function step(timestamp) {
    if (!start) start = timestamp;
    const progress = timestamp - start;
    if (progress < duration) {
      const x = (Math.random() - 0.5) * intensity;
      const y = (Math.random() - 0.5) * intensity;
      container.style.transform = `translate(${x}px, ${y}px)`;
      requestAnimationFrame(step);
    } else {
      container.style.transform = originalTransform;
    }
  }
  requestAnimationFrame(step);
}
      // pointer tracking for slicing
      let pointerPath = []; // last points
      const MAX_PATH = 6;

      // fruits
      const fruits = [];
      const gravity = 0.28;

      // spawn settings
      let spawnInterval = 800; // ms
      let lastSpawn = 0;

      // Roznamcha fruit appears about 1 in 12 spawns
      function randomFruit(x){
        const t = Math.random();
        if(t < 0.08) return {type:'bomb'}; // bombs cause -points
        if(t < 0.15) return {type:'roz'}; // roznamcha special
        const kinds = ['apple','orange','kiwi','banana','grape','melon'];
        return {type: kinds[Math.floor(Math.random()*kinds.length)]};
      }

   function spawn(now){
  lastSpawn = now;
  const startX = 40 + Math.random() * (canvas.width/devicePixelRatio - 80);
  let vy = 0.5 + Math.random() * 1;
  const vx = (Math.random() - 0.5) * 1.5;
  const f = randomFruit(startX);
const radius = (f.type === 'bomb') ? 40 : (f.type === 'roz' ? 50 : 34 + Math.random() * 8);  // Set gravity conditionally
  let gravity = 0.18; // default for normal fruits
  if (f.type === 'roz') {
    vy *= 0.7;       // slower initial fall for Roznamcha fruit
    gravity = 0.12;  // override gravity to make it float gently
  }

  fruits.push({
    x: startX,
    y: -radius,
    vx,
    vy,
    ax: 0,
    ay: gravity,     // âœ… This is where you "pass" it â€” just use the variable!
    r: radius,
    type: f.type,
    spawned: now,
    hit: false,
    shards: []
  });
}
      // drawing helpers
      function drawFruit(fr){
        ctx.save();
        ctx.translate(fr.x,fr.y);
        ctx.fillText('Ø¨Ù…Ø¨ âš ï¸', 0, 0);
        // shadow
         ctx.beginPath();
  ctx.ellipse(0, fr.r + 8, fr.r * 0.9, fr.r * 0.35, 0, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.fill();

        // body
         if (fr.type === 'bomb') {
    ctx.beginPath();
    ctx.arc(0, 0, fr.r, 0, Math.PI * 2);
    ctx.fillStyle = '#111'; // Dark bomb
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px Vazirmatn,Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Ø¨Ù…Ø¨', 0, 0);
  } else if (fr.type === 'roz') {
    // Roznamcha branded fruit (purple-green gradient)
    const g = ctx.createLinearGradient(-fr.r, -fr.r, fr.r, fr.r);
    g.addColorStop(0, '#6c1aa8');
    g.addColorStop(1, '#10b981');
    ctx.beginPath();
    ctx.arc(0, 0, fr.r, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.font = 'bold 16px Vazirmatn,Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡', 0, 0);
  } else {
    // Normal fruits with beautiful colors
    const colors = {
      apple: '#ef4444',
      orange: '#fb923c',
      kiwi: '#86efac',
      banana: '#facc15',
      grape: '#7c3aed',
      melon: '#34d399'
    };
    const col = colors[fr.type] || '#f97316'; // fallback to orange

    ctx.beginPath();
    ctx.arc(0, 0, fr.r, 0, Math.PI * 2);
    ctx.fillStyle = col; // âœ… THIS MUST BE SET BEFORE FILL
    ctx.fill();

    // Draw label
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '600 15px Vazirmatn,Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const label = fr.type === 'apple' ? 'Ø³ÛŒØ¨' :
                  fr.type === 'orange' ? 'Ù¾Ø±ØªÙ‚Ø§Ù„' :
                  fr.type === 'kiwi' ? 'Ú©ÛŒÙˆÛŒ' :
                  fr.type === 'banana' ? 'Ù…ÙˆØ²' :
                  fr.type === 'grape' ? 'Ø§Ù†Ú¯ÙˆØ±' : 'Ø®Ø±Ø¨Ø²Ù‡';
    ctx.fillText(label, 0, 0);
  }

  ctx.restore();
}

      // particle shards when sliced
      function createShards(fr, cx, cy){
        const pieces = 8 + Math.floor(Math.random()*6);
        for(let i=0;i<pieces;i++){
          const ang = Math.random()*Math.PI*2;
          const spd = 2 + Math.random()*5;
          fr.shards.push({x:cx,y:cy,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:40 + Math.random()*30,col: (fr.type==='roz'?'#9b5cf6':'#fff')});
        }
      }

      // slicing detection: check segment intersect circle
      function segmentCircle(x1,y1,x2,y2,cx,cy,r){
        const vx = x2-x1, vy = y2-y1;
        const wx = cx - x1, wy = cy - y1;
        const proj = (vx*wx + vy*wy) / (vx*vx + vy*vy || 1);
        const closestX = x1 + Math.max(0, Math.min(1, proj)) * vx;
        const closestY = y1 + Math.max(0, Math.min(1, proj)) * vy;
        const dx = closestX - cx, dy = closestY - cy;
        return (dx*dx + dy*dy) <= r*r;
      }

      // pointer events
      let pointerDown = false;
      function addPointerPoint(x,y){
        pointerPath.push({x,y,t:Date.now()});
        if(pointerPath.length>MAX_PATH) pointerPath.shift();
      }

      canvas.addEventListener('pointerdown', e=>{ pointerDown=true; addPointerPoint(e.offsetX, e.offsetY); e.preventDefault(); });
      canvas.addEventListener('pointermove', e=>{ if(!pointerDown) return; addPointerPoint(e.offsetX, e.offsetY); e.preventDefault(); });
      canvas.addEventListener('pointerup', e=>{ pointerDown=false; pointerPath.length=0; e.preventDefault(); });
      canvas.addEventListener('pointercancel', ()=>{ pointerDown=false; pointerPath.length=0; });

      // touch fallback: prevent scroll
      canvas.addEventListener('touchstart', e=>{ e.preventDefault(); }, {passive:false});

      // main loop
      let lastTime = performance.now();
      function loop(now){
        const dt = now - lastTime; lastTime = now;
        if(!running){ draw(); requestAnimationFrame(loop); return; }

        // spawn
        if(now - lastSpawn > spawnInterval){ spawn(now); }

        // update fruits
        for(let i=fruits.length-1;i>=0;i--){
          const f = fruits[i];
          if(f.hit){
            // update shards
            for(let s of f.shards){ s.vy += 0.14; s.x += s.vx; s.y += s.vy; s.life -= 1; }
            if(f.shards.length && f.shards.every(s=>s.life<=0)) fruits.splice(i,1);
            continue;
          }

          f.vy += f.ay; f.x += f.vx; f.y += f.vy;

          // out of screen -> remove
          if(f.y - f.r > canvas.height/devicePixelRatio + 60){ fruits.splice(i,1); continue; }

          // check slice with pointer path
          if(pointerPath.length>1){
            for(let p=0;p<pointerPath.length-1;p++){
              const a = pointerPath[p], b = pointerPath[p+1];
              if(segmentCircle(a.x, a.y, b.x, b.y, f.x, f.y, f.r)){
                // sliced!
                f.hit = true;
                createShards(f, f.x, f.y);
                // scoring
                if(f.type==='bomb'){ score = Math.max(0, score - 20);flashScreen('#ff4444', 200); shakeScreen(8, 300);  }
                else if(f.type==='roz'){ score += 100; flashRozMessage(); }
                else score += 10;
                scoreEl.textContent = score;
                break;
              }
            }
          }
        }

        // update shards life for fruits that are hit
        for(const f of fruits){ if(f.hit){ f.shards = f.shards.filter(s=>s.life>0); }}

        // decrease timer
        // use dt to reduce time smoothly
        timeLeft -= dt/1000;
        if(timeLeft <= 0){ timeLeft = 0; running=false; showOverlay(); }
        timeEl.textContent = Math.ceil(timeLeft);

        draw();
        requestAnimationFrame(loop);
      }

      function draw(){
        // clear
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // background subtle
        ctx.fillStyle = 'rgba(250,252,255,0.35)'; ctx.fillRect(0,0,canvas.width/devicePixelRatio,canvas.height/devicePixelRatio);

        // draw fruits
        for(const f of fruits){ if(!f.hit) drawFruit(f); else {
          // draw shards
          for(const s of f.shards){ ctx.fillStyle = s.col; ctx.beginPath(); ctx.arc(s.x, s.y, 3,0,Math.PI*2); ctx.fill(); }
        }}

        // draw pointer path
        if(pointerPath.length>1){ ctx.strokeStyle='rgba(255,255,255,0.92)'; ctx.lineWidth=6; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(pointerPath[0].x, pointerPath[0].y);
          for(let i=1;i<pointerPath.length;i++) ctx.lineTo(pointerPath[i].x, pointerPath[i].y);
          ctx.stroke();
        }
      }

      // special roz message
      let rozMsgTimer = 0;
      function flashRozMessage(){ rozMsgTimer = 60; }

      // overlay
      function showOverlay(){ overlay.classList.add('show'); overlayTitle.textContent = 'Ø¢ÙØ±ÛŒÙ†!'; overlayText.textContent = `Ø§Ù…ØªÛŒØ§Ø² Ø´Ù…Ø§ ${score} â€” Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø¨Ù‡ØªØ± Ú©Ø³Ø¨â€ŒÙˆÚ©Ø§Ø±ØŒ Ø§Ù¾ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ø±Ø§ Ù†ØµØ¨ Ú©Ù†ÛŒØ¯.`; }

      // start
      requestAnimationFrame(loop);

      // spawn rhythm control
setInterval(()=>{ 
  if(spawnInterval > 500) spawnInterval = Math.max(500, spawnInterval - 10); // slower ramp-up
}, 5000);
      // small tutorial auto-touch for first run
      setTimeout(()=>{ // spawn a few fruits quickly so player sees
        for(let i=0;i<3;i++) spawn(performance.now() + i*120);
      },600);

      // optional: clicking overlay restarts
      overlay.addEventListener('click', ()=>{ overlay.classList.remove('show'); restart(); });

      function restart(){ score=0; timeLeft=60; running=true; fruits.length=0; pointerPath.length=0; scoreEl.textContent=score; spawnInterval=700; lastSpawn=0; }

    })();
  </script>
</body>
</html>
