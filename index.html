<!doctype html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Ø¯Ù…Ùˆ Ø¨Ø§Ø²ÛŒ â€” Ù‚Ø·Ø¹ Ù…ÛŒÙˆÙ‡ (Roznamcha)</title>
  <style>
    :root{
      --bg:#0b1320; --panel:#ffffff; --accent:#6c1aa8; --accent-2:#10b981; --muted:#8b95a1;
      --cta:#0ea5a3;
    }
    html,body{height:100%;margin:0;font-family:Vazirmatn,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071226 0%, #071a2b 100%);display:flex;align-items:center;justify-content:center;padding:14px}
    .container{width:100%;max-width:900px;border-radius:14px;background:linear-gradient(180deg,#ffffff,#f8fafc);overflow:hidden;box-shadow:0 20px 60px rgba(2,6,23,.6)}
    header{display:flex;justify-content:space-between;align-items:center;padding:14px 18px;border-bottom:1px solid #eef2f7}
    header h1{margin:0;font-size:1.1rem;color:var(--bg);font-weight:800}
    header .score{font-weight:800;color:var(--muted)}

    .stage{position:relative;background:linear-gradient(180deg,#eaf3ff,#ffffff);height:560px;display:flex;align-items:center;justify-content:center}
    canvas{width:100%;height:100%;display:block}

    .hud{display:flex;gap:12px;align-items:center;padding:12px 18px;border-top:1px solid #eef2f7;background:linear-gradient(180deg,#ffffff,#f8fafc)}
    .hud .info{flex:1;color:#24303a;font-weight:700}
    .hud .timer{font-weight:900;color:var(--accent)}

    /* floating download CTA */
    .cta{position:absolute;left:16px;bottom:16px;z-index:60;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#fff;padding:12px 16px;border-radius:14px;font-weight:900;box-shadow:0 12px 30px rgba(12,20,40,.35);text-decoration:none}

    /* overlay end screen */
    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(3,7,18,0.45),rgba(3,7,18,0.65));backdrop-filter:blur(2px);z-index:80;display:none}
    .overlay.show{display:flex}
    .card{background:#fff;padding:22px;border-radius:12px;max-width:420px;text-align:center}
    .card h2{margin:0 0 10px 0;color:var(--bg)}
    .card p{color:var(--muted);margin:0 0 18px 0}
    .download-btn{display:inline-block;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#fff;padding:12px 18px;border-radius:10px;text-decoration:none;font-weight:800}

    /* Roznamcha watermark */
    .watermark{position:absolute;right:18px;top:18px;opacity:.08;font-size:42px;color:#000;pointer-events:none;font-weight:900}

    /* responsive */
    @media (max-width:640px){ .stage{height:70vh} .watermark{font-size:30px} }
  </style>
</head>
<body>
  <div class="container" role="application">
    <header>
      <h1>Ù…ÛŒÙˆÙ‡ Ù‡Ø§ Ø±Ù‡ Ù‚Ø·Ø¹ Ú©Ùˆ â€” Ù‡Ù…Ú©Ø§Ø± Ùˆ Ø¯ÙˆØ³Øª Ø´Ù…Ø§ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡</h1>
      <div class="score">Ø§Ù…ØªÛŒØ§Ø²: <span id="score">0</span></div>
    </header>

    <div class="stage">
      <canvas id="gameCanvas" width="900" height="560" style="touch-action: none;" aria-label="Ø¨Ø§Ø²ÛŒ Ù‚Ø·Ø¹ Ù…ÛŒÙˆÙ‡"></canvas>

      <div class="watermark">Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ø¯Ø³ØªÛŒØ§Ø± Ù…Ø§Ù„ÛŒ Ø¯Ú©Ø§Ù† Ø´Ù…Ø§</div>

      <a class="cta" id="floatingCta" href="https://github.com/MLd10Sar/Esmat/releases/download/v1.0.0/app-release.apk" target="_blank">ğŸ“² Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡</a>

      <div class="overlay" id="overlay">
        <div class="card">
          <h2 id="overlayTitle">Ø®Ø³ØªÙ‡ Ù†Ø¨Ø§Ø´ÛŒ!</h2>
          <p id="overlayText">Ú©Ø§Ù…ÛŒØ§Ø¨ Ø¨Ø§Ø´ÛŒ Ø¯ÙˆØ³Øª Ø¹Ø²ÛŒØ² Ø§Ú¯Ø± Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®ÙˆØ´Øª Ø¢Ù…Ø¯ Ùˆ Ø®ÙˆØ§Ø³ØªÛŒ Ù‡Ù…Ø§ÛŒØª Ú©Ù†ÛŒØŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ø±Ø§ Ù†ØµØ¨ Ùˆ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù† Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ù…Ø«Ù„ Ú©ØªØ§Ø¨Ú†Ù‡ Ø±Ø³ÛŒØ¯Ø§Øª ÛŒØ§ Ù„ÛŒØ¬Ø± Ø§Ø³Øª Ú©Ù‡ ØªÙ…Ø§Ù… Ø¯Ø®Ù„ Ùˆ Ø®Ø±Ø¬ Ùˆ Ù‚Ø±Ø¶ Ùˆ Ø·Ù„Ø¨ Ú¯Ø¯Ø§Ù… Ø®ÙˆØ¯ Ø±Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÛŒØªØ§Ù†ÛŒ Ùˆ Ù‡Ø± Ø¬Ù†Ø³ Ø±Ù‡ Ú©Ù‡ Ø¨ÛŒØ§Ø±ÛŒ ÙÙ‚Ø· ÛŒÚ© Ø¯ÙØ¹Ù‡ Ø±Ø§Ø¬Ø³ØªØ±Ø´ Ú©Ùˆ Ùˆ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ø¨Ø±Øª ØªØ¹Ù‚ÛŒØ¨ Ø§Ø´ Ù…ÛŒÚ©Ù†Ù‡ Ø§ÙˆØªÙˆÙ…Ø§Øª Ùˆ Ù‡Ø§ ÛŒØ§Ø¯Ù… Ù†Ø±Ù‡ Ú©Ù‡ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ù¾ÛŒØ§Ù… Ù‡Ù… Ø¨Ø±Øª Ø±ÙˆØ§Ù† Ù…ÛŒÚ©Ù†Ù‡ Ù‡Ø± Ø±ÙˆØ² Ø§Ú¯Ù‡ ØªØ¨ Ø®ÙˆØ´ Ø¨Ø§Ø´Ù‡ Ø§Ø² ÙØ§ÛŒØ¯Ù‡ Ùˆ Ù†Ù‚Øµ Ø±ÙˆØ²Øª Ù…ÛŒÚ¯Ù‡ Ú©Ù‡ Ú†Ù‚Ø¯Ù‡ ÙØ§ÛŒØ¯Ù‡ Ú©Ø¯ÛŒ Ùˆ Ú†Ù‚Ø¯Ø± Ø¶Ø±Ø± Ú©Ø¯ÛŒ Ø¯ÛŒÚ¯Ù‡ Ø®Ø¯Ø§ ÛŒØ§Ø± Ùˆ Ù†Ú¯Ù‡Ø¯Ø§Ø±Øª.</p>
          <a id="overlayDownload" class="download-btn" href="https://github.com/MLd10Sar/Esmat/releases/download/v1.0.0/app-release.apk" target="_blank">ğŸ“¥ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø§Ù¾ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡</a>
        </div>
      </div>
    </div>

    <div class="hud">
      <div class="info">Ù…ÛŒÙˆÙ‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØµÙˆØµ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ø±Ø§ Ù‚Ø·Ø¹ Ú©Ù†ÛŒØ¯ ØªØ§ Ù¾ÛŒØ§Ù… ÙˆÛŒÚ˜Ù‡ Ø¨Ø¨ÛŒÙ†ÛŒØ¯.</div>
      <div class="timer">Ø²Ù…Ø§Ù†: <span id="time">60</span>s</div>
    </div>
  </div>

  <script>
    // Fruit Cutter â€” Simple, mobile-friendly, Roznamcha-branded
    (function(){
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const timeEl = document.getElementById('time');
      const overlay = document.getElementById('overlay');
      const overlayTitle = document.getElementById('overlayTitle');
      const overlayText = document.getElementById('overlayText');

      // logical size independent from CSS size
      function fitCanvas(){
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.round(rect.width * devicePixelRatio);
        canvas.height = Math.round(rect.height * devicePixelRatio);
        ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
      }
      fitCanvas();
      window.addEventListener('resize', fitCanvas);
      window.addEventListener('load', fitCanvas);
      let score = 0;
      let timeLeft = 60; // seconds
      let running = true;

      const sounds = {
  slice: new Audio('slice.mp3'),
  explosion: new Audio('explosion.mp3'),
  sour: new Audio('sour.mp3'),
  golden: new Audio('golden.mp3'),
  gameover: new Audio('gameover.mp3')
};

// Optional: Set volume
Object.values(sounds).forEach(sound => {
  sound.volume = 0.4; // Softer, not too loud
});
      function flashScreen(color, duration) {
  const flash = document.createElement('div');
  Object.assign(flash.style, {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    background: color,
    opacity: 0.3,
    pointerEvents: 'none',
    zIndex: 9999,
  });
  document.body.appendChild(flash);
  setTimeout(() => {
    flash.style.transition = 'opacity 0.2s';
    flash.style.opacity = '0';
    setTimeout(() => flash.remove(), 200);
  }, duration);
}

    function shakeScreen(intensity = 5, duration = 200) {
  const container = document.querySelector('.container');
  const originalTransform = container.style.transform || '';
  let start = null;
  function step(timestamp) {
    if (!start) start = timestamp;
    const progress = timestamp - start;
    if (progress < duration) {
      const x = (Math.random() - 0.5) * intensity;
      const y = (Math.random() - 0.5) * intensity;
      container.style.transform = `translate(${x}px, ${y}px)`;
      requestAnimationFrame(step);
    } else {
      container.style.transform = originalTransform;
    }
  }
  requestAnimationFrame(step);
}
      // pointer tracking for slicing
      let pointerPath = []; // last points
      const MAX_PATH = 6;

      // fruits
      const fruits = [];
      const gravity = 0.28;

      // spawn settings
      let spawnInterval = 800; // ms
      let lastSpawn = 0;

      // Roznamcha fruit appears about 1 in 12 spawns
      function randomFruit(x){
        const t = Math.random();
        if(t < 0.08) return {type:'bomb'}; // bombs cause -points
        if(t < 0.15) return {type:'roz'}; // roznamcha special
        const kinds = ['apple','orange','kiwi','banana','grape','melon', 'strawberry', 'pineapple', 'mango', 'cherry','lemon', 'golden'];
        return {type: kinds[Math.floor(Math.random()*kinds.length)]};
      }

   function spawn(now){
  lastSpawn = now;
  const startX = 40 + Math.random() * (canvas.width/devicePixelRatio - 80);
  let vy = 0.5 + Math.random() * 1;
  const vx = (Math.random() - 0.5) * 1.5;
  const f = randomFruit(startX);
  let radius;
if (f.type === 'bomb') {
  radius = 40;
} else if (f.type === 'roz') {
  radius = 50;
} else if (f.type === 'pineapple') {
  radius = 42; // bigger!
} else if (f.type === 'cherry') {
  radius = 28; // smaller and cute
} else {
  radius = 34 + Math.random() * 8;
}
  let gravity = 0.18; // default for normal fruits
  if (f.type === 'roz') {
    vy *= 0.7;       // slower initial fall for Roznamcha fruit
    gravity = 0.12;  // override gravity to make it float gently
  }

  fruits.push({
    x: startX,
    y: -radius,
    vx,
    vy,
    ax: 0,
    ay: gravity,     // âœ… This is where you "pass" it â€” just use the variable!
    r: radius,
    type: f.type,
    spawned: now,
    hit: false,
    shards: []
  });
}
      // drawing helpers
      function drawFruit(fr){
        ctx.save();
        ctx.translate(fr.x,fr.y);
        // shadow
        ctx.beginPath();
        ctx.ellipse(0, fr.r + 8, fr.r * 0.9, fr.r * 0.35, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.12)';
        ctx.fill();

        // body
         if (fr.type === 'bomb') {
    ctx.beginPath();
    ctx.arc(0, 0, fr.r, 0, Math.PI * 2);
    ctx.fillStyle = '#111'; // Dark bomb
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px Vazirmatn,Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Ø¨Ù…Ø¨', 0, 0);
  } else if (fr.type === 'roz') {
    // Roznamcha branded fruit (purple-green gradient)
     const g = ctx.createLinearGradient(-fr.r, -fr.r, fr.r, fr.r);
    g.addColorStop(0, '#6c1aa8');
    g.addColorStop(1, '#10b981');
    ctx.beginPath();
    ctx.arc(0, 0, fr.r, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.font = 'bold 16px Vazirmatn,Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡', 0, 0);
  } else if (fr.type === 'banana') {
    // Banana as ellipse
     ctx.save();

    // Rotate slightly for natural curve
    ctx.rotate(-0.3); // slight tilt

    // Draw banana body with curve
    ctx.beginPath();
    ctx.moveTo(-fr.r * 1.2, 0);
    ctx.quadraticCurveTo(0, -fr.r * 0.8, fr.r * 1.2, 0); // top curve
    ctx.quadraticCurveTo(0, fr.r * 0.4, -fr.r * 1.2, 0);   // bottom curve
    ctx.fillStyle = '#facc15';
    ctx.fill();

    // Add subtle highlight
    ctx.beginPath();
    ctx.moveTo(-fr.r * 1.1, -2);
    ctx.quadraticCurveTo(0, -fr.r * 0.6, fr.r * 1.0, -2);
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Add stem (small brown cap at top)
    ctx.beginPath();
    ctx.ellipse(0, -fr.r * 0.7, fr.r * 0.2, fr.r * 0.15, 0, 0, Math.PI * 2);
    ctx.fillStyle = '#8B4513'; // SaddleBrown
    ctx.fill();

    // Label
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.font = '600 14px Vazirmatn,Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Ù…ÙˆØ²', 0, fr.r * 0.3);

    ctx.restore();
  } else {
    // Normal fruits with beautiful colors
    const colors = {
      apple: '#ef4444',
      orange: '#fb923c',
      kiwi: '#86efac',
      banana: '#facc15',
      grape: '#7c3aed',
      melon: '#34d399',
      strawberry: '#ec4899',   // ğŸ’– Pink
      pineapple: '#fbbf24',   // ğŸŸ¡ Golden yellow
      mango: '#f97316',       // ğŸŸ  Bright orange
      cherry: '#be123c',       // â¤ï¸ Deep red
      lemon: '#fde047',       // ğŸ‹ Lemon yellow
      golden: '#fbbf24'       // ğŸŒŸ Golden (weâ€™ll override with gradient)
    };
    const col = colors[fr.type] || '#f97316'; // fallback to orange


      // Normal circle fruits

    ctx.beginPath();
    ctx.arc(0, 0, fr.r, 0, Math.PI * 2);
    ctx.fillStyle = col; // âœ… THIS MUST BE SET BEFORE FILL
    ctx.fill();
    

    // Draw label
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '600 15px Vazirmatn,Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    let label = 'Ù…ÛŒÙˆÙ‡';
switch(fr.type) {
  case 'apple': label = 'Ø³ÛŒØ¨'; break;
  case 'orange': label = 'Ú©ÛŒÙ†Ùˆ'; break;
  case 'kiwi': label = 'Ú©ÛŒÙˆÛŒ'; break;
  case 'banana': label = 'Ú©ÛŒÙ„Ù‡'; break;
  case 'grape': label = 'Ø§Ù†Ú¯ÙˆØ±'; break;
  case 'melon': label = 'Ø®Ø±Ø¨ÙˆØ²Ù‡'; break;
  case 'strawberry': label = 'ØªÙˆØª ÙØ±Ù†Ú¯ÛŒ'; break;
  case 'pineapple': label = 'Ø¢Ù†Ø§Ù†Ø§Ø³'; break;
  case 'mango': label = 'Ø§Ù…'; break;
  case 'cherry': label = 'Ú¯ÛŒÙ„Ø§Ø³'; break;
  case 'lemon': label = 'Ù„ÛŒÙ…Ùˆ ğŸ‹'; break;       // ğŸ‹
  case 'golden': label = 'Ø·Ù„Ø§ÛŒÛŒ ğŸŒŸ'; break;     // ğŸŒŸ
}
    ctx.fillText(label, 0, 0);
  }

  ctx.restore();
}

      // particle shards when sliced
      function createShards(fr, cx, cy){
        const pieces = 8 + Math.floor(Math.random()*6);
        for(let i=0;i<pieces;i++){
          const ang = Math.random()*Math.PI*2;
          const spd = 2 + Math.random()*5;
          fr.shards.push({x:cx,y:cy,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:40 + Math.random()*30,col: (fr.type==='roz'?'#9b5cf6':'#fff')});
        }
      }

      // slicing detection: check segment intersect circle
      function segmentCircle(x1,y1,x2,y2,cx,cy,r){
        const vx = x2-x1, vy = y2-y1;
        const wx = cx - x1, wy = cy - y1;
        const proj = (vx*wx + vy*wy) / (vx*vx + vy*vy || 1);
        const closestX = x1 + Math.max(0, Math.min(1, proj)) * vx;
        const closestY = y1 + Math.max(0, Math.min(1, proj)) * vy;
        const dx = closestX - cx, dy = closestY - cy;
        return (dx*dx + dy*dy) <= r*r;
      }

      // pointer events
      let pointerDown = false;
      function addPointerPoint(x,y){
        pointerPath.push({x,y,t:Date.now()});
        if(pointerPath.length>MAX_PATH) pointerPath.shift();
      }

      canvas.addEventListener('pointerdown', e=>{ pointerDown=true; addPointerPoint(e.offsetX, e.offsetY); e.preventDefault(); });
      canvas.addEventListener('pointermove', e=>{ if(!pointerDown) return; addPointerPoint(e.offsetX, e.offsetY); e.preventDefault(); });
      canvas.addEventListener('pointerup', e=>{ pointerDown=false; pointerPath.length=0; e.preventDefault(); });
      canvas.addEventListener('pointercancel', ()=>{ pointerDown=false; pointerPath.length=0; });

      // touch fallback: prevent scroll
      canvas.addEventListener('touchstart', e=>{ e.preventDefault(); }, {passive:false});

      // main loop
      let lastTime = performance.now();
      function loop(now){
        const dt = now - lastTime; lastTime = now;
        if(!running){ draw(); requestAnimationFrame(loop); return; }

        // spawn
        if(now - lastSpawn > spawnInterval){ spawn(now); }

        // update fruits
        for(let i=fruits.length-1;i>=0;i--){
          const f = fruits[i];
          if(f.hit){
            // update shards
            for(let s of f.shards){ s.vy += 0.14; s.x += s.vx; s.y += s.vy; s.life -= 1; }
            if(f.shards.length && f.shards.every(s=>s.life<=0)) fruits.splice(i,1);
            continue;
          }

          f.vy += f.ay; f.x += f.vx; f.y += f.vy;

          // out of screen -> remove
          if(f.y - f.r > canvas.height/devicePixelRatio + 60){ fruits.splice(i,1); continue; }

          // check slice with pointer path
          if(pointerPath.length>1){
            for(let p=0;p<pointerPath.length-1;p++){
              const a = pointerPath[p], b = pointerPath[p+1];
              if(segmentCircle(a.x, a.y, b.x, b.y, f.x, f.y, f.r)){
                // sliced!
                f.hit = true;
                createShards(f, f.x, f.y);
                // scoring
                if(f.type==='bomb'){
  score = Math.max(0, score - 20);
  flashScreen('#ff4444', 200);
  sounds.explosion.cloneNode().play().catch(e=>console.log("Sound failed"));
} else if(f.type==='lemon'){
  score = Math.max(0, score - 5);
  flashScreen('#ffff00', 150);
  sounds.sour.cloneNode().play().catch(e=>console.log("Sound failed"));
} else if(f.type==='golden'){
  score += 50;
  flashScreen('#ffd700', 300);
  sounds.golden.cloneNode().play().catch(e=>console.log("Sound failed"));
} else if(f.type==='roz'){
  score += 100;
  flashRozMessage();
  sounds.slice.cloneNode().play().catch(e=>console.log("Sound failed")); // or special sound
} else {
  score += 10;
  sounds.slice.cloneNode().play().catch(e=>console.log("Sound failed"));
}
                scoreEl.textContent = score;
                break;
              }
            }
          }
        }

        // update shards life for fruits that are hit
        for(const f of fruits){ if(f.hit){ f.shards = f.shards.filter(s=>s.life>0); }}

        // decrease timer
        // use dt to reduce time smoothly
        timeLeft -= dt/1000;
        if(timeLeft <= 0){ timeLeft = 0; running=false; showOverlay(); }
        timeEl.textContent = Math.ceil(timeLeft);

        draw();
        requestAnimationFrame(loop);
      }
  

      function draw(){
        // clear
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // background subtle
        ctx.fillStyle = 'rgba(250,252,255,0.35)'; ctx.fillRect(0,0,canvas.width/devicePixelRatio,canvas.height/devicePixelRatio);

        // draw fruits
        for(const f of fruits){ if(!f.hit) drawFruit(f); else {
          // draw shards
          for(const s of f.shards){ ctx.fillStyle = s.col; ctx.beginPath(); ctx.arc(s.x, s.y, 3,0,Math.PI*2); ctx.fill(); }
        }}

        // draw pointer path
        if(pointerPath.length>1){ ctx.strokeStyle='rgba(255,255,255,0.92)'; ctx.lineWidth=6; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(pointerPath[0].x, pointerPath[0].y);
          for(let i=1;i<pointerPath.length;i++) ctx.lineTo(pointerPath[i].x, pointerPath[i].y);
          ctx.stroke();
        }
      }

      // special roz message
      let rozMsgTimer = 0;
      function flashRozMessage(){ rozMsgTimer = 60; }

      // overlay
      function showOverlay(){ overlay.classList.add('show'); overlayTitle.textContent = 'Ø¢ÙØ±ÛŒÙ†!'; overlayText.textContent = `Ø§Ù…ØªÛŒØ§Ø² Ø´Ù…Ø§ ${score} â€” Ú©Ø§Ù…ÛŒØ§Ø¨ Ø¨Ø§Ø´ÛŒ Ø¯ÙˆØ³Øª Ø¹Ø²ÛŒØ² Ø§Ú¯Ø± Ø§Ø² Ø¨Ø§Ø²ÛŒ Ø®ÙˆØ´Øª Ø¢Ù…Ø¯ Ùˆ Ø®ÙˆØ§Ø³ØªÛŒ Ù‡Ù…Ø§ÛŒØª Ú©Ù†ÛŒØŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ø±Ø§ Ù†ØµØ¨ Ùˆ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù† Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ù…Ø«Ù„ Ú©ØªØ§Ø¨Ú†Ù‡ Ø±Ø³ÛŒØ¯Ø§Øª ÛŒØ§ Ù„ÛŒØ¬Ø± Ø§Ø³Øª Ú©Ù‡ ØªÙ…Ø§Ù… Ø¯Ø®Ù„ Ùˆ Ø®Ø±Ø¬ Ùˆ Ù‚Ø±Ø¶ Ùˆ Ø·Ù„Ø¨ Ùˆ Ú¯Ø¯Ø§Ù… Ø®ÙˆØ¯ Ø±Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÛŒØªØ§Ù†ÛŒ Ù‡Ø± Ø¬Ù†Ø³ Ø±Ù‡ Ú©Ù‡ Ø¯Ù‡ Ø¯Ú©Ø§Ù† Ø¨ÛŒØ§Ø±ÛŒ ÙÙ‚Ø· ÛŒÚ© Ø¯ÙØ¹Ù‡ Ø±Ø§Ø¬Ø³ØªØ± Ù…ÛŒÚ©Ù†ÛŒ Ø¯Ø± Ú¯Ø¯Ø§Ù… Ùˆ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ø¨Ø±Ø§ÛŒØª ØªØ¹Ù‚ÛŒØ¨ Ø§Ø´ Ù…ÛŒÚ©Ù†Ù‡ Ø§ÙˆØªÙˆÙ…Ø§Øª Ùˆ Ù‡Ø§ ÛŒØ§Ø¯Ù… Ù†Ø±Ù‡ Ú©Ù‡ Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ Ù¾ÛŒØ§Ù… Ù‡Ù… Ø¨Ø±Øª Ø±ÙˆØ§Ù† Ù…ÛŒÚ©Ù†Ù‡ Ù‡Ø± Ø±ÙˆØ² Ø§Ú¯Ù‡ ØªØ¨ Ø®ÙˆØ´ Ø¨Ø§Ø´Ù‡ Ø§Ø² ÙØ§ÛŒØ¯Ù‡ Ùˆ Ù†Ù‚Øµ Ø±ÙˆØ²Øª Ù…ÛŒÚ¯Ù‡ Ú©Ù‡ Ú†Ù‚Ø¯Ù‡ ÙØ§ÛŒØ¯Ù‡ Ú©Ø¯ÛŒ Ùˆ Ú†Ù‚Ø¯Ø± Ø¶Ø±Ø± Ú©Ø¯ÛŒ Ùˆ Ù‡Ø§ Ù…ÛŒØªØ§Ù†ÛŒ Ù„ÙˆÚ¯ÙˆÛŒ Ø¯Ú©Ø§Ù† Ø§Øª Ø±Ù‡ Ù‡Ù… Ø¯Ø± Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø¨Ø§ Ù†Ø§Ù… Ùˆ Ø¢Ø¯Ø±Ø³ Ø¨Ø§Ù†ÛŒ Ú©Ù‡ Ù‡Ø± ÙˆÙ‚Øª Ø®ÙˆØ§Ø³ØªÛŒ ÙˆØ±Ù‚ Ø±Ø³ÛŒØ¯ ÛŒØ§ Ù¾Ø´Øª Ù‚Ø±Ø¶ Ø¨Ø±ÛŒ Ø¨Ø¬Ø§ÛŒ ÙˆØ±Ù‚ Ø¹Ø§Ø¯ÛŒ Ø§Ø² Ù„ÙˆÚ¯ÙˆÛŒ Ø®ÙˆØ¯Øª Ù…Ø«Ù„ ÛŒÚ© Ø´Ø±Ú©Øª Ø¨Ù‡ Ø·Ø±Ù Ù…Ù‚Ø§Ø¨Ù„ Ø±ÙˆØ§Ù† Ú©Ù†ÛŒ ÛŒÚ© Ø³Ù†Ø¯ Ø±Ø³Ù…ÛŒ Ùˆ Ù‚ÙˆÛŒ Ù¾ÛŒØ´ Ø®ÙˆØ¯ Ù…ÛŒØ¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒ Ø¨Ù‡ Ù†Ø§Ù… Ø¯Ú©Ø§Ù† Ø§Øª Ú©Ù‡ Ø¨Ø³ÛŒØ§Ø± Ø¯Ø± Ø¢ÛŒÙ†Ø¯Ù‡ Ø¨Ø±Øª Ú©Ø§Ø± Ø¢Ù…Ø¯ Ù…ÛŒØ´Ù‡ Ø¯ÛŒÚ¯Ù‡ Ø®Ø¯Ø§ ÛŒØ§Ø± Ùˆ Ù†Ú¯Ù‡Ø¯Ø§Ø±Øª.`; sounds.gameover.play().catch(e=>console.log("Game over sound failed"));}

      // start
      requestAnimationFrame(loop);

      // spawn rhythm control
setInterval(()=>{ 
  if(spawnInterval > 500) spawnInterval = Math.max(500, spawnInterval - 10); // slower ramp-up
}, 5000);
      // small tutorial auto-touch for first run
      setTimeout(()=>{ // spawn a few fruits quickly so player sees
        for(let i=0;i<3;i++) spawn(performance.now() + i*120);
      },600);

      // optional: clicking overlay restarts
      overlay.addEventListener('click', ()=>{ overlay.classList.remove('show'); restart(); });

      function restart(){ score=0; timeLeft=60; running=true; fruits.length=0; pointerPath.length=0; scoreEl.textContent=score; spawnInterval=700; lastSpawn=0; }

      function unlockAudio() {
        Object.values(sounds).forEach(sound => sound.play().catch(() => {}));
        if (bgMusic) bgMusic.play().catch(() => {});
        canvas.removeEventListener('touchstart', unlockAudio);
        canvas.removeEventListener('click', unlockAudio);
      }

      canvas.addEventListener('touchstart', unlockAudio, { once: true });
      canvas.addEventListener('click', unlockAudio, { once: true });

    })();
  </script>
</body>
</html>