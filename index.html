<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Ø¯Ù…ÙˆÛŒ Ù„ÙˆØ¯Ùˆ â€” ØªØ¨Ù„ÛŒØº Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡</title>
  <style>
    :root{
      --bg:#0f1724; --card:#fff; --muted:#6b7280;
      --p1:#ef4444; --p2:#3b82f6; --p3:#f59e0b; --p4:#10b981;
      --space-size:44px;
      --board-size:min(520px,90vw);
    }
    html,body{height:100%;margin:0;font-family:Vazirmatn,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071033 0%, #071a2b 100%);padding:18px}
    .card{width:var(--board-size);background:var(--card);border-radius:16px;box-shadow:0 20px 50px rgba(2,6,23,.6);overflow:hidden}
    header{padding:14px 18px;border-bottom:1px solid #f1f5f9;display:flex;gap:12px;align-items:center;justify-content:space-between}
    header h1{font-size:1.05rem;margin:0;color:#0f1724}
    header .promo{display:flex;gap:8px;align-items:center}
    .promo a{background:var(--p2);color:white;padding:8px 12px;border-radius:10px;text-decoration:none;font-weight:700}

    .board-wrap{display:flex;flex-direction:column;align-items:center;padding:18px}
    .board{width:100%;max-width:480px;height:480px;position:relative;background:linear-gradient(180deg,#f8fafc, #ffffff);border-radius:12px;display:flex;align-items:center;justify-content:center}

    /* circular path */
    svg.path{width:90%;height:90%;position:absolute}
    .space{position:absolute;width:var(--space-size);height:var(--space-size);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#111;border:4px solid #fff;box-shadow:0 6px 18px rgba(2,6,23,.25);transform:translate(-50%,-50%);transition:left .28s linear, top .28s linear}

    /* player pieces */
    .piece{width:34px;height:34px;border-radius:50%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:800;border:3px solid #fff;box-shadow:0 6px 18px rgba(2,6,23,.35);position:absolute;transform:translate(-50%,-50%);transition:left .28s linear, top .28s linear}

    .piece.p1{background:var(--p1)}.piece.p2{background:var(--p2)}.piece.p3{background:var(--p3)}.piece.p4{background:var(--p4)}

    .controls{width:100%;display:flex;gap:12px;padding:16px;border-top:1px solid #f1f5f9;align-items:center;justify-content:space-between}
    .dice-btn{width:86px;height:86px;border-radius:14px;border:none;background:#0f1724;color:white;font-size:2.2rem;display:flex;align-items:center;justify-content:center;box-shadow:0 10px 30px rgba(2,6,23,.4);cursor:pointer}
    .info{flex:1;text-align:center;color:var(--muted);font-weight:700}

    .turn-indicator{display:flex;gap:8px;align-items:center}
    .turn-dot{width:12px;height:12px;border-radius:50%}

    /* mobile tweaks */
    @media (max-width:420px){:root{--space-size:36px} .board{height:380px}}

    /* modal promo */
    .bottom-banner{background:linear-gradient(90deg,#0f1724 0%, rgba(15,23,36,0.8)100%);color:#fff;padding:12px 14px;display:flex;gap:12px;align-items:center;justify-content:space-between}
    .download{background:linear-gradient(90deg,var(--p2),var(--p4));padding:10px 14px;border-radius:10px;color:white;font-weight:800;text-decoration:none}

    .credits{font-size:12px;color:var(--muted);padding:8px 14px;text-align:center}
  </style>
</head>
<body>
  <div class="card" role="application">
    <header>
      <h1>Ø¯Ù…Ùˆ â€” Ø¨Ø§Ø²ÛŒ Ø´Ø¨ÛŒÙ‡ Ù„ÙˆØ¯Ùˆ (Ù†Ù…Ø§ÛŒØ´)</h1>
      <div class="promo">
        <span style="color:var(--muted);font-size:.95rem">ØªØ¨Ù„ÛŒØº: Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù† Roznamcha</span>
        <a href="https://github.com/MLd10Sar/Esmat/releases/download/v1.0.0/app-release.apk" target="_blank" rel="noopener">Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø§Ù¾</a>
      </div>
    </header>

    <div class="board-wrap">
      <div class="board" id="board" aria-hidden="false">
        <svg class="path" viewBox="0 0 400 400" preserveAspectRatio="xMidYMid meet">
          <!-- circular path visual only -->
          <defs>
            <filter id="glow"><feGaussianBlur stdDeviation="3" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
          </defs>
          <circle cx="200" cy="200" r="135" stroke="#e6eef8" stroke-width="52" fill="none" stroke-linecap="round" filter="url(#glow)"/>
        </svg>
      </div>

      <div class="controls">
        <div class="turn-indicator" id="turnIndicator">
          <div style="display:flex;flex-direction:column;align-items:flex-end">
            <div style="font-weight:800">Ù†ÙˆØ¨Øª:</div>
            <div id="currentPlayerLabel" style="font-weight:900;color:#0f1724">Ø¨Ø§Ø²ÛŒÚ©Ù† 1</div>
          </div>
        </div>

        <div class="info" id="info">Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ØŒ ØªØ§Ø³ Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.</div>

        <button class="dice-btn" id="diceBtn" aria-label="ØªØ§Ø³"><span id="diceFace">ğŸ²</span></button>
      </div>

      <div class="credits">Ù‚ÙˆØ§Ù†ÛŒÙ† Ø³Ø§Ø¯Ù‡ Ø´Ø¯Ù‡: Ù‡Ø± Ø¨Ø§Ø²ÛŒÚ©Ù† ÛŒÚ© Ù…Ù‡Ø±Ù‡ Ø¯Ø§Ø±Ø¯ØŒ Ú©Ø³ÛŒ Ú©Ù‡ ÛŒÚ© Ø¯ÙˆØ± Ú©Ø§Ù…Ù„ Ú¯Ø±Ø¯Ø¯ Ø¨Ø±Ù†Ø¯Ù‡ Ø§Ø³Øª. Ø§Ú¯Ø± Ø±ÙˆÛŒ Ù…Ù‡Ø±Ù‡Ù” Ø­Ø±ÛŒÙ ÙØ±ÙˆØ¯ Ø¢ÛŒÛŒØ¯ØŒ Ø§Ùˆ Ø¨Ù‡ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø¯.</div>
    </div>

    <div class="bottom-banner">
      <div style="display:flex;flex-direction:column">
        <strong>Ø±ÙˆØ²Ù†Ø§Ù…Ú†Ù‡ â€” Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ùˆ Ù…Ø¯ÛŒØ±ÛŒØª Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø¨Ø±Ø§ÛŒ Ú©Ø³Ø¨â€ŒÙˆÚ©Ø§Ø±Ù‡Ø§</strong>
        <span style="font-size:13px;color:#cbd5e1">Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ Ø¨Ø§Ø²ÛŒ Ø¯Ø± Ø§Ù¾ Ø´Ù…Ø§ Ù†Ù…Ø§ÛŒØ´ Ø¯Ø§Ø¯Ù‡ Ø´ÙˆØ¯ØŸ Ø§ÛŒÙ† Ù†Ø³Ø®Ù‡ Ù†Ù…Ø§ÛŒØ´ÛŒ Ø³Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø¬Ø°Ø¨ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡ Ø§Ø³Øª.</span>
      </div>
      <a class="download" href="https://github.com/MLd10Sar/Esmat/releases/download/v1.0.0/app-release.apk" target="_blank" rel="noopener">Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø§Ù¾ Roznamcha</a>
    </div>
  </div>

  <script>
    // Simple Ludo-like demo with 4 players (single piece each)
    (function(){
      const board = document.getElementById('board');
      const diceBtn = document.getElementById('diceBtn');
      const diceFace = document.getElementById('diceFace');
      const info = document.getElementById('info');
      const currentPlayerLabel = document.getElementById('currentPlayerLabel');

      const center = {x: board.clientWidth/2, y: board.clientHeight/2};
      // We'll compute positions relative to SVG viewBox (400x400)
      const cx = 200, cy = 200, radius = 135;
      const spaces = 20; // loop spaces
      const players = [ {id:1,color:'p1'}, {id:2,color:'p2'}, {id:3,color:'p3'}, {id:4,color:'p4'} ];
      const state = { pos: [ -1, -1, -1, -1 ], // -1 means at home
                      finished: [false,false,false,false],
                      cur: 0, rolling:false };

      // create space markers (hidden small dots for positioning)
      const spacePoints = [];
      for(let i=0;i<spaces;i++){
        const angle = (i / spaces) * Math.PI*2 - Math.PI/2; // start top
        const x = cx + Math.cos(angle)*radius;
        const y = cy + Math.sin(angle)*radius;
        spacePoints.push({x,y});

        // optional small visual for spaces
        const dot = document.createElement('div');
        dot.className = 'space';
        dot.style.left = x + 'px';
        dot.style.top = y + 'px';
        dot.style.width = '12px'; dot.style.height='12px'; dot.style.borderRadius='50%'; dot.style.border='2px solid rgba(255,255,255,0.6)'; dot.style.background='rgba(255,255,255,0.02)';
        board.appendChild(dot);
      }

      // create pieces
      const pieces = [];
      players.forEach((p, idx)=>{
        const el = document.createElement('div');
        el.className = `piece ${p.color}`;
        el.textContent = p.id;
        // start off-board near corners
        const startAngles = [ -40, 50, 140, -140];
        const a = startAngles[idx]*Math.PI/180;
        const sx = cx + Math.cos(a)*(radius+70);
        const sy = cy + Math.sin(a)*(radius+70);
        el.style.left = sx+'px'; el.style.top = sy+'px';
        board.appendChild(el);
        pieces.push(el);
      });

      function placePieceOnSpace(playerIndex, spaceIndex){
        // spaceIndex may be -1 (home)
        if(spaceIndex<0){
          // move to home cluster near corner
          const startAngles = [ -40, 50, 140, -140];
          const a = startAngles[playerIndex]*Math.PI/180;
          const sx = cx + Math.cos(a)*(radius+70);
          const sy = cy + Math.sin(a)*(radius+70);
          pieces[playerIndex].style.left = sx+'px'; pieces[playerIndex].style.top = sy+'px';
        } else {
          const sp = spacePoints[spaceIndex % spaces];
          pieces[playerIndex].style.left = sp.x+'px'; pieces[playerIndex].style.top = sp.y+'px';
        }
      }

      function updateUI(){
        currentPlayerLabel.textContent = 'Ø¨Ø§Ø²ÛŒÚ©Ù† ' + (state.cur+1);
      }

      function nextTurn(){
        // if someone already finished all loop (we'll treat finish when made a full loop)
        let alive = false;
        for(let i=0;i<4;i++){ if(!state.finished[i]) alive=true }
        if(!alive){ info.textContent='Ø¨Ø§Ø²ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯.'; return; }

        // move to next non-finished
        do{ state.cur = (state.cur+1)%4; }while(state.finished[state.cur]);
        updateUI();
        state.rolling=false;
      }

      function rollDiceForCurrent(){
        if(state.rolling) return;
        state.rolling=true;
        diceBtn.disabled = true;
        diceFace.textContent='...';
        // short rolling animation
        const rollAnim = setInterval(()=>{ diceFace.textContent = Math.floor(Math.random()*6)+1; }, 80);
        setTimeout(()=>{
          clearInterval(rollAnim);
          const val = Math.floor(Math.random()*6)+1;
          diceFace.textContent = val;
          info.textContent = 'Ø´Ù…Ø§ ' + val + ' Ø§Ù†Ø¯Ø§Ø®ØªÛŒØ¯.';
          movePiece(state.cur, val);
        }, 700);
      }

      function movePiece(playerIndex, steps){
        // if at home (-1), must roll 6 to enter
        const curPos = state.pos[playerIndex];
        if(curPos===-1){
          if(steps===6){
            state.pos[playerIndex]=0; // enter at space 0 + player offset
          } else {
            info.textContent = 'Ø¨Ø±Ø§ÛŒ ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ Ø¨Ø§ÛŒØ¯ 6 Ø¨ÛŒÙ†Ø¯Ø§Ø²ÛŒØ¯.';
            state.rolling=false; diceBtn.disabled=false; nextTurn(); return;
          }
        } else {
          const next = curPos + steps;
          // check finish condition: if next >= spaces -> finish
          if(next >= spaces){
            state.finished[playerIndex]=true;
            state.pos[playerIndex]=spaces-1; // put on last space visually
            placePieceOnSpace(playerIndex, state.pos[playerIndex]);
            info.textContent = 'Ø¨Ø§Ø²ÛŒÚ©Ù† ' + (playerIndex+1) + ' Ø¯ÙˆØ± Ú©Ø§Ù…Ù„ Ø²Ø¯ Ùˆ Ø¨ÛŒØ±ÙˆÙ† Ø¢Ù…Ø¯ â€” Ø¨Ø±Ù†Ø¯Ù‡!';
            diceBtn.disabled=true; // pause
            // highlight winner and stop game
            pieces[playerIndex].style.transform = 'translate(-50%,-50%) scale(1.18)';
            return;
          } else {
            state.pos[playerIndex] = next;
          }
        }

        // adjust position with player-specific starting offset so each player starts at different place on loop
        const offset = playerIndex * Math.floor(spaces/4);
        const effectivePos = (state.pos[playerIndex] + offset) % spaces;
        placePieceOnSpace(playerIndex, effectivePos);

        // if landed on opponent, send them home
        for(let i=0;i<4;i++){
          if(i===playerIndex) continue;
          if(state.pos[i]>=0){
            const off = (state.pos[i] + i*Math.floor(spaces/4))%spaces;
            if(off === effectivePos){
              state.pos[i] = -1; // send home
              placePieceOnSpace(i, -1);
              info.textContent += ` Ùˆ Ù…Ù‡Ø±Ù‡Ù” Ø¨Ø§Ø²ÛŒÚ©Ù† ${i+1} Ø¨Ø±Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù‡ Ø´Ø¯.`;
            }
          }
        }

        // after moving, unlock next player's turn
        state.rolling=false;
        diceBtn.disabled=false;
        // simple rule: if rolled 6 they get another turn
        if(steps!==6) nextTurn(); else { info.textContent += ' (6 Ø²Ø¯ â€” ÛŒÚ© Ù†ÙˆØ¨Øª Ø¯ÛŒÚ¯Ø±)'; }
      }

      // AI: when it's not player 0 (human), auto-roll after short delay
      function autoPlayIfNeeded(){
        if(state.cur===0 || state.finished[state.cur]) return; // human is player 0
        setTimeout(()=>{
          // simulate click
          rollDiceForCurrent();
        }, 700 + Math.random()*700);
      }

      // attach click
      diceBtn.addEventListener('click', ()=>{
        if(state.cur!==0) return; // only allow human when their turn
        rollDiceForCurrent();
      });

      // initialize UI positions
      for(let i=0;i<4;i++){ placePieceOnSpace(i, -1); }
      updateUI();

      // game loop watcher for AI turns
      const watcher = setInterval(()=>{
        if(!state.rolling && state.cur!==0 && !state.finished[state.cur]){
          autoPlayIfNeeded();
        }
      },300);

      // handle window resize to reposition pieces using computed board size
      window.addEventListener('resize', ()=>{
        // recompute center and points based on current element size
        const rect = board.getBoundingClientRect();
        const scale = rect.width/400; // we designed on 400 viewBox
        // recompute using bounding box
        const newCx = rect.width/2; const newCy = rect.height/2; const newR = Math.min(rect.width,rect.height)/2 - 80;
        // rebuild points
        for(let i=0;i<spaces;i++){
          const angle = (i / spaces) * Math.PI*2 - Math.PI/2;
          const x = newCx + Math.cos(angle)*newR;
          const y = newCy + Math.sin(angle)*newR;
          spacePoints[i].x = x; spacePoints[i].y = y;
        }
        // reposition pieces
        for(let i=0;i<4;i++){
          const p = state.pos[i];
          if(p<0) placePieceOnSpace(i,-1); else placePieceOnSpace(i, (p + i*Math.floor(spaces/4))%spaces);
        }
      });

      // initial resize trigger
      setTimeout(()=>{ window.dispatchEvent(new Event('resize')); },100);
    })();
  </script>
</body>
</html>
